diff --git a/modules/skparagraph/samples/SampleParagraph.cpp b/modules/skparagraph/samples/SampleParagraph.cpp
index edb84821db..cf0629b299 100644
--- a/modules/skparagraph/samples/SampleParagraph.cpp
+++ b/modules/skparagraph/samples/SampleParagraph.cpp
@@ -3689,30 +3689,22 @@ class ParagraphView65 : public ParagraphView_Base {
 protected:
     SkString name() override { return SkString("ParagraphView65"); }
 
-    bool onChar(SkUnichar uni) override {
-            switch (uni) {
-                case 't':
-                    substituteTab = !substituteTab;
-                    return true;
-                default:
-                    break;
-            }
-            return false;
-    }
-
     void onDrawContent(SkCanvas* canvas) override {
 
         canvas->drawColor(SK_ColorWHITE);
         ParagraphStyle paragraph_style;
         paragraph_style.setReplaceTabCharacters(substituteTab);
-        auto collection = getFontCollection();
-        ParagraphBuilderImpl builder(paragraph_style, collection);
+        auto fontCollection = sk_make_sp<FontCollection>();
+        fontCollection->setDefaultFontManager(SkFontMgr::RefDefault());
+        fontCollection->enableFontFallback();
+        ParagraphBuilderImpl builder(paragraph_style, fontCollection);
         TextStyle text_style;
         text_style.setColor(SK_ColorBLACK);
+        // "Noto Sans Thai"
         text_style.setFontFamilies({SkString("Roboto")});
         text_style.setFontSize(100);
         builder.pushStyle(text_style);
-        builder.addText("There is a tab>\t<right here");
+        builder.addText(u"\u0eb9\u0952\u0301\u0e51A");
         auto paragraph = builder.Build();
         paragraph->layout(this->width());
         paragraph->paint(canvas, 0, 0);
diff --git a/modules/skparagraph/src/OneLineShaper.cpp b/modules/skparagraph/src/OneLineShaper.cpp
index 482236a034..31b69c43c4 100644
--- a/modules/skparagraph/src/OneLineShaper.cpp
+++ b/modules/skparagraph/src/OneLineShaper.cpp
@@ -494,13 +494,30 @@ void OneLineShaper::matchResolvedFonts(const TextStyle& textStyle,
             const char* ch = unresolvedText.begin();
             // We have the global cache for all already found typefaces for SkUnichar
             // but we still need to keep track of all SkUnichars used in this unresolved block
-            SkTHashSet<SkUnichar> alreadyTried;
-            SkUnichar unicode = nextUtf8Unit(&ch, unresolvedText.end());
+            SkTHashSet<SkUnichar> alreadyTriedCodepoints;
+            SkTHashSet<SkTypefaceID> alreadyTriedTypefaces;
             while (true) {
 
-                sk_sp<SkTypeface> typeface;
+                if (ch == unresolvedText.end()) {
+                    // Not a single codepoint could be resolved but we finished the block
+                    hopelessBlocks.push_back(fUnresolvedBlocks.front());
+                    fUnresolvedBlocks.pop_front();
+                    break;
+                }
+
+                // See if we can switch to the next DIFFERENT codepoint
+                SkUnichar unicode = -1;
+                while (ch != unresolvedText.end()) {
+                    unicode = nextUtf8Unit(&ch, unresolvedText.end());
+                    if (!alreadyTriedCodepoints.contains(unicode)) {
+                        alreadyTriedCodepoints.add(unicode);
+                        break;
+                    }
+                }
+                SkASSERT(unicode != -1);
 
                 // First try to find in in a cache
+                sk_sp<SkTypeface> typeface;
                 FontKey fontKey(unicode, textStyle.getFontStyle(), textStyle.getLocale());
                 auto found = fFallbackFonts.find(fontKey);
                 if (found != nullptr) {
@@ -515,35 +532,36 @@ void OneLineShaper::matchResolvedFonts(const TextStyle& textStyle,
                     fFallbackFonts.set(fontKey, typeface);
                 }
 
+                // Check if we already tried this font on this text range
+                if (!alreadyTriedTypefaces.contains(typeface->uniqueID())) {
+                    alreadyTriedTypefaces.add(typeface->uniqueID());
+                } else {
+                    continue;
+                }
+
+                auto resolvedBlocksBefore = fResolvedBlocks.size();
                 auto resolved = visitor(typeface);
                 if (resolved == Resolved::Everything) {
-                    // Resolved everything, no need to try another font
-                    return;
+                    if (hopelessBlocks.empty()) {
+                        // Resolved everything, no need to try another font
+                        return;
+                    } else if (resolvedBlocksBefore < fResolvedBlocks.size()) {
+                        // There are some resolved blocks
+                        resolved = Resolved::Something;
+                    } else {
+                        // All blocks are hopeless
+                        resolved = Resolved::Nothing;
+                    }
                 }
 
                 if (resolved == Resolved::Something) {
                     // Resolved something, no need to try another codepoint
                     break;
                 }
-
-                if (ch == unresolvedText.end()) {
-                    // Not a single codepoint could be resolved but we finished the block
-                    hopelessBlocks.push_back(fUnresolvedBlocks.front());
-                    fUnresolvedBlocks.pop_front();
-                    break;
-                }
-
-                // We can stop here or we can switch to another DIFFERENT codepoint
-                while (ch != unresolvedText.end()) {
-                    unicode = nextUtf8Unit(&ch, unresolvedText.end());
-                    if (alreadyTried.find(unicode) == nullptr) {
-                        alreadyTried.add(unicode);
-                        break;
-                    }
-                }
             }
         }
 
+        // Return hopeless blocks back
         for (auto& block : hopelessBlocks) {
             fUnresolvedBlocks.emplace_front(block);
         }
@@ -713,6 +731,8 @@ bool OneLineShaper::shape() {
                 }
 
                 if (fUnresolvedBlocks.empty()) {
+                    // In some cases it does not mean everything
+                    // (when we excluded some hopeless blocks from the list)
                     return Resolved::Everything;
                 } else if (resolvedCount < fResolvedBlocks.size()) {
                     return Resolved::Something;
@@ -736,33 +756,10 @@ TextRange OneLineShaper::clusteredText(GlyphRange& glyphs) {
     enum class Dir { left, right };
     enum class Pos { inclusive, exclusive };
 
-    // [left: right)
-    auto findBaseChar = [&](TextIndex index, Dir dir) -> TextIndex {
-
-        if (dir == Dir::right) {
-            while (index < fCurrentRun->fTextRange.end) {
-                if (this->fParagraph->codeUnitHasProperty(index,
-                                                          CodeUnitFlags::kGraphemeStart)) {
-                    return index;
-                }
-                ++index;
-            }
-            return fCurrentRun->fTextRange.end;
-        } else {
-            while (index > fCurrentRun->fTextRange.start) {
-                if (this->fParagraph->codeUnitHasProperty(index,
-                                                          CodeUnitFlags::kGraphemeStart)) {
-                    return index;
-                }
-                --index;
-            }
-            return fCurrentRun->fTextRange.start;
-        }
-    };
 
     TextRange textRange(normalizeTextRange(glyphs));
-    textRange.start = findBaseChar(textRange.start, Dir::left);
-    textRange.end = findBaseChar(textRange.end, Dir::right);
+    // textRange.start = findBaseChar(textRange.start, Dir::left);
+    // textRange.end = findBaseChar(textRange.end, Dir::right);
 
     // Correct the glyphRange in case we extended the text to the grapheme edges
     // TODO: code it without if (as a part of LTR/RTL refactoring)
